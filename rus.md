# Дизайн кода: организация JavaScript

Великолепный дизайн это результат заботливого и внимательного
отношения к тому, что важно, который в итоге приводит к
полезному, понятному и, надо надеяться, красивому интерфейсу. Но
обманывайте себя, дизайн это удел не только дизайнеров.

Существует множество дизайнерских решений в программировании, и говоря
это я подразумеваю дизайн не пользовательского интерфейса, а дизайн
самого кода.

Хорошо спроектированный код намного легче поддерживать, улучшать,
расширять и позволяет разработчикам быть эффективнее. Это
приводит к тому, что больше внимания и энергии будет потрачено на
значимые вещи, что в свою очередь осчастливит всех — пользователей,
разработчиков, все заинтересованные стороны.

Существуют три действительно важных высокоуровневых, языково-
независимых аспекта дизайна кода:

1. Архитектура — программная база для всего кода. Правила,
определяющие как различные компоненты (модель, представление и
контроллер) взаимодействуют друг с другом.
2. Поддерживаемость – насколько хорошо код может быть улучшен или расширена
его функциональность?
3. Повторное использование — насколько возможно
использовать заново отдельные компоненты приложения? Насколько гибка в
настройке каждая отдельная реализация каждого компонента?

В менее удачных языках, например в JavaScript, для написания удобного и
приятного кода потребуется немного самодисциплины.
JavaScript-окружение настолько дружелюбно к разработчику, что можно «разбросать»
куски кода по разным углам вашего приложения — устроить настоящий
бардак, но, тем временем, приложение всё равно будет работать.
Грамотное планирование и разработка архитектуры на раннем этапе
развития (и следование ей в дальнейшем) привнесёт в ваш код
ограничения, которые позволят вам добиться согласованности.

Я хочу показать вам один проверенный временем паттерн разработки,
которым горжусь, — паттерн «Модуль», чья расширяемая структура
дополнит вашу архитектуру до состояния стройной, поддерживаемой и
расширяемой программной базы. Мне нравится создавать модули с помощью
системы jQuery-плагинов, так как это обеспечивает удивительную
возможность повторного использования, набор удобных опций и
превосходно созданное API.

Ниже по тексту я расскажу вам, как писать ваш код организуя его в
модули, которые можно будет использовать в ваших следующих проектах.

## Паттерн «Модуль»

Существует *множество* паттернов разработки и не меньше ресурсов, где с ними можно ознакомится. [Эдди Османи (Addy Osmani)][1] написал [потрясающую (бесплатную!) книгу][2] о паттернах в JavaScript, которую я настоятельно рекомендую разработчикам любого уровня.

Паттерн [Модуль][3] позволяет структурировать ваш код и поддерживать его в хорошо организованном состоянии. «Модуль» это обычный объект, который содержит методы и свойства. Лучшее в нем — его простота: даже тот, кто не знаком с классическими паттернами разработки посмотрев на него сможет понять как он работает.

В приложениях, которые используют этот паттерн, каждый компонент заключен в собственный модуль. Например, что бы добавить функцию автодополнения текста, вы создаете модуль, который работает с текстовым полем и модуль для списка вариантов дополнения. Эти два модуля будут работать вместе, но модуль, который работает с текстовым полем не работает со списком вариантов и наоборот.

Именно из за такого разделение задач компонентов паттерн «модуль» отлично подходит для создания надежной архитектуры системы. Отношения внутри приложения четко определены. Все, что касается текстового поля, выполняется с помощью соответствующего модуля, функционал не рассредоточен по всему коду и как результат он остается чистым.

Еще одним достоинством модульной организации является простота его поддержки. Модули можно улучшать и оптимизировать независимо, не затрагивая никаких других частей приложения.

Я использовал паттерн «модуль» для создания структуры [jPanelMenu][4], плагина jQuery, который создает меню, скрывающееся за пределами экрана. Именно его я и использую для того, что бы проиллюстрировать процесс создания модуля.

## Создание модуля

Сначала я определяю три метода и свойство, которые определяют взаимодействие с меню.

    var jpm = {
        animated: true,
        openMenu: function( ) {
            …
            this.setMenuStyle( );
        },
        closeMenu: function( ) {
            …
            this.setMenuStyle( );
        },
        setMenuStyle: function( ) { … }
    };

Идея заключается в том, что бы разбить код на минимальные блоки, пригодные для повторного использования. Я бы мог написать просто метод `toggleMenu()`, но создание методов `openMenu()` и `closeMenu()` обеспечивает лучший контроль и большие возможности повторного использования внутри модуля.

Обратите внимание, что обращения к методам и свойствам внутри модуля (например вызов `setMenuStyle()`) происходят с использованием `this`.

Это основная структура модуля. Можно продолжать добавлять методы и свойства, но это будет не сложнее, чем добавление тех, что уже есть. После того, как структура готова, на ее основе можно добавить то, что нужно для повторного использования модуля: настройки и API.

## jQuery-плагины

Третий аспект проектирования кода, возможно самый важный: пригодность его к повторному использованию. И тут есть подвох. Да, можно написать на чистом JavaScript и внедрить модули пригодные для повторного использования (мы на 90% закончили модуль, который описан выше), но я по ряду причин предпочитаю для более сложных вещей использовать jQuery-плагины.

Самая важная из них заключается в ненавязчивых связях. Если для построения
компонента используется jQuery, то очевидно, что для его имплементации он нужен.

Кроме того, код, с помощью которого вы имплементируете компонент будет
однороден с остальным кодом проекта, использующего jQuery. Это хорошо с точки
зрения эстетики и, кроме того, делает код предсказуемым: разработчик сможет
понять как работать с плагином без длительного изучения документации. Это ещё
один способ создать удобный для разработчиков интерфейс.

Прежде чем начать писать jQuery-плагин нужно удостоверится, что он не конфликтует с другими JavaScript библиотеками, которые используют `$`-нотацию. Это проще, чем может показаться:

    (function($) {
        // код jQuery-плагина
    })(jQuery);

Плагин это просто метод определенный в объекте jQuery. Помещаем уже созданный нами модуль внутрь него.

    (function($) {
        $.jPanelMenu = function( ) {
            var jpm = {
                animated: true,
                openMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                closeMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                setMenuStyle: function( ) { … }
            };
        };
    })(jQuery);

Все что нужно для вызова плагина — вызвать созданную вами функцию.

    var jpm = $.jPanelMenu( );

## Настройки

Настройки необходимы для любого приспособленного для повторного использования плагина, ведь они позволяют приводить его к требованиям каждого конкретного проекта, который несет с собой массу специфических стилей, способов взаимодействия и структур данных.

Считается хорошим тоном по умолчанию устанавливать в настройках хорошо продуманные значения. Самый простой способ это сделать — использовать метод jQuery `$.extend( )`, который принимает 2 и более аргументов.

В качестве первого аргумента `$.extend( )` передается объект содержащий все
настраиваемые свойства и их значения по умолчанию. В качестве второго
аргумента передается объект, который содержит настройки, которые передал
пользователь. Метод `$.extend()` объединит эти два объекта,
перезаписывая стандартные настройки переданными пользователем.

    (function($) {
        $.jPanelMenu = function(options) {
            var jpm = {
                options: $.extend({
                    'animated': true,
                    'duration': 500,
                    'direction': 'left'
                }, options),
                openMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                closeMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                setMenuStyle: function( ) { … }
            };
        };
    })(jQuery);

В то время как вы предоставляете полезные стандартные настройки для
вашего плагина, также сами настройки своими названиями могут объяснять
своё предназначение, что позволяет понять, что делает код с первого
взгляда.

Старайтесь предоставлять все настройки, которые могут понадобится разработчику.
Гибкость поможет внедрять плагин в последующие проекты, и тем более,
что гибкие настройки никогда не причиняли вреда.

## API

Настройки — отличный способ контролировать поведение плагина. API, с другой
стороны, позволяет расширять его функциональные возможности, предоставляя
доступ к свойствам и методам в процессе имплементации.

Хорошо, когда API дает максимум возможностей, однако не стоит давать доступ
ко всем внутренним методам и свойствам. В идеале вам стоит предоставить
доступ к тем из них, которые будут реально использоваться.

В нашем примере API должен содержать методы, которые позволят открыть и
закрыть меню, ничего более. Внутренний метод `setMenuStyle()` вызывается,
когда меню открывается или закрывается, но публичный доступ к нему не нужен.

Что бы дать доступ к API нужно сделать так, что бы в конце кода плагина
возвращался объект с его методами и свойствами. Можно даже связать эти методы
и свойства с теми, которые используются внутри модуля, именно в этом случае
достоинства паттерна «модуль» видны лучше всего.

    (function($) {
        $.jPanelMenu = function(options) {
            var jpm = {
                options: $.extend({
                    'animated': true,
                    'duration': 500,
                    'direction': 'left'
                }, options),
                openMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                closeMenu: function( ) {
                    …
                    this.setMenuStyle( );
                },
                setMenuStyle: function( ) { … }
            };
            return {
                open: jpm.openMenu,
                close: jpm.closeMenu,
                someComplexMethod: function( ) { … }
            };
        };
    })(jQuery);

Методы и свойства API будут доступны из объекта, который возвращается при инициализации плагина.

    var jpm = $.jPanelMenu({
        duration: 1000,
        …
    });
    jpm.open( );

## Улучшение интерфейсов

Что бы облегчить себе жизнь мы, руководствуясь простыми правилами, создали
расширяемый, подходящий для повторного использования плагин.
Поэкспериментируйте, что бы разобраться подходит ли он вам и вашей команде, вписывается ли в рамки вашего рабочего процесса.

Каждый раз, когда пишу код, который вероятно можно будет использовать повторно, я создаю модульный jQuery-плагин. Лучшее в этом подходе то, что он заставляет использовать и тестировать написанный вами код и в процессе вы быстро выясняете его сильные стороны и недостатки, а значит можете планировать изменения.

В результате на выходе у нас оттестированный, готовый к открытию для сторонних разработчиков или продаже код. Свои лучшие плагины я выложил на [GitHub][5].

О дизайне кода важно думать даже если вы разрабатываете что то, что не будет реально использоваться. В будущем будете себе за это благодарны.



[1]: https://twitter.com/addyosmani "@addyosmani"
[2]: http://addyosmani.com/resources/essentialjsdesignpatterns/book/ "Essential JS Design Patterns"

[3]: http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
[4]: http://jpanelmenu.com/
[5]: https://github.com/acolangelo "github/acolangelo"
